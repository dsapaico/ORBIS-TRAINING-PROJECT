'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AssetCollection = require('../domain/asset-collection');
var AssetServer = require('./asset-server');
var AssetBuilder = require('./asset-builder');
var chalk = require('chalk');

var DEFAULT_DEST = 'build'; // The default destination
var DEFAULT_PORT = 7100; // The default port number
var DEFAULT_DEBUG_PAGE_TITLE = 'Welcome to <i>Bulbo</i> asset path debug page!';
var DEFAULT_DEBUG_PAGE_PATH = '__bulbo__';

/**
 * AssetService manages, builds and serves the collection of assets.
 */

var AssetService = function () {
  function AssetService() {
    var _this = this;

    _classCallCheck(this, AssetService);

    this.assets = new AssetCollection();

    this.reset();

    this.assets.on('error', function (err, asset) {
      _this.logger.log(chalk.red('Error: ' + asset.toString()));

      if (err.stack != null) {
        // log stack if available
        _this.logger.log(chalk.red(err.stack));
      } else {
        // log error itself if stack is null
        _this.logger.log(chalk.red(err));
      }
    });
  }

  _createClass(AssetService, [{
    key: 'setLogger',
    value: function setLogger(logger) {
      this.logger = logger;
    }

    /**
     * Adds the asset
     * @private
     * @param {Asset} asset The asset
     */

  }, {
    key: 'addAsset',
    value: function addAsset(asset) {
      this.assets.add(asset);
    }

    /**
     * Serves the assets.
     * @return {Promise} Resolves when the server started
     */

  }, {
    key: 'serve',
    value: function serve() {
      var _this2 = this;

      var server = new AssetServer(this.assets, this.port, this.logger, this.debugPageTitle, this.debugPagePath);

      server.on('reading', function (asset) {
        return _this2.logger.log(chalk.yellow('Reading:'), chalk.magenta(asset.toString()));
      });
      server.on('changed', function (asset) {
        return _this2.logger.log(chalk.yellow('Changed:'), chalk.magenta(asset.toString()));
      });
      server.on('ready', function (asset) {
        return _this2.logger.log(chalk.green('Ready:'), chalk.magenta(asset.toString()));
      });

      this.watcher = server;

      return server.serve({ base: this.base });
    }

    /**
     * Builds the assets.
     * @return {Promise} Resolves when the assets built
     */

  }, {
    key: 'build',
    value: function build() {
      return new AssetBuilder(this.assets, this.dest, this.logger).build({ base: this.base });
    }

    /**
     * Watches and builds the assets.
     */

  }, {
    key: 'watchAndBuild',
    value: function watchAndBuild() {
      var _this3 = this;

      var builder = new AssetBuilder(this.assets, this.dest, this.logger);

      builder.on('reading', function (asset) {
        return _this3.logger.log(chalk.yellow('Reading:'), chalk.magenta(asset.toString()));
      });
      builder.on('changed', function (asset) {
        return _this3.logger.log(chalk.yellow('Changed:'), chalk.magenta(asset.toString()));
      });
      builder.on('ready', function (asset) {
        return _this3.logger.log(chalk.green('Ready:'), chalk.magenta(asset.toString()));
      });

      this.watcher = builder;

      builder.watchAndBuild({ base: this.base });
    }

    /**
     * Unwatches the asset if a server or a builder exists.
     */

  }, {
    key: 'unwatch',
    value: function unwatch() {
      if (this.watcher) {
        this.watcher.unwatch();
      }
    }

    /**
     * Sets the port number.
     * @param {Number} port The port number
     */

  }, {
    key: 'setPort',
    value: function setPort(port) {
      this.port = port;
    }

    /**
     * Sets the destination.
     * @param {String} dest The destination of the build
     */

  }, {
    key: 'setDest',
    value: function setDest(dest) {
      this.dest = dest;
    }

    /**
     * Sets the debug page title.
     * @param {string} debugPageTitle The debug page title
     */

  }, {
    key: 'setDebugPageTitle',
    value: function setDebugPageTitle(debugPageTitle) {
      this.debugPageTitle = debugPageTitle;
    }

    /**
     * Sets the debug page path.
     * @param {string} debugPagePath The debug page path
     */

  }, {
    key: 'setDebugPagePath',
    value: function setDebugPagePath(debugPagePath) {
      this.debugPagePath = debugPagePath;
    }

    /**
     * @param {string} base The default base path for assets.
     */

  }, {
    key: 'setAssetBasePath',
    value: function setAssetBasePath(base) {
      this.base = base;
    }

    /**
     * Returns if the assets are empty.
     * @return {Boolean}
     */

  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      return this.assets.isEmpty();
    }

    /**
     * Clears all the assets.
     */

  }, {
    key: 'clear',
    value: function clear() {
      this.reset();
    }

    /**
     * Resets the settings.
     */

  }, {
    key: 'reset',
    value: function reset() {
      this.assets.empty();

      this.base = null;
      this.dest = DEFAULT_DEST;
      this.port = DEFAULT_PORT;
      this.debugPageTitle = DEFAULT_DEBUG_PAGE_TITLE;
      this.debugPagePath = DEFAULT_DEBUG_PAGE_PATH;
    }
  }]);

  return AssetService;
}();

module.exports = AssetService;